// Code generated by Prisma (prisma@1.34.8). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  event: (where?: EventWhereInput) => Promise<boolean>;
  news: (where?: NewsWhereInput) => Promise<boolean>;
  prices: (where?: PricesWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  event: (where: EventWhereUniqueInput) => EventNullablePromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  news: (where: NewsWhereUniqueInput) => NewsNullablePromise;
  newses: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<News>;
  newsesConnection: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NewsConnectionPromise;
  prices: (where: PricesWhereUniqueInput) => PricesNullablePromise;
  priceses: (args?: {
    where?: PricesWhereInput;
    orderBy?: PricesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Prices>;
  pricesesConnection: (args?: {
    where?: PricesWhereInput;
    orderBy?: PricesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PricesConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createNews: (data: NewsCreateInput) => NewsPromise;
  updateNews: (args: {
    data: NewsUpdateInput;
    where: NewsWhereUniqueInput;
  }) => NewsPromise;
  updateManyNewses: (args: {
    data: NewsUpdateManyMutationInput;
    where?: NewsWhereInput;
  }) => BatchPayloadPromise;
  upsertNews: (args: {
    where: NewsWhereUniqueInput;
    create: NewsCreateInput;
    update: NewsUpdateInput;
  }) => NewsPromise;
  deleteNews: (where: NewsWhereUniqueInput) => NewsPromise;
  deleteManyNewses: (where?: NewsWhereInput) => BatchPayloadPromise;
  createPrices: (data: PricesCreateInput) => PricesPromise;
  updatePrices: (args: {
    data: PricesUpdateInput;
    where: PricesWhereUniqueInput;
  }) => PricesPromise;
  updateManyPriceses: (args: {
    data: PricesUpdateManyMutationInput;
    where?: PricesWhereInput;
  }) => BatchPayloadPromise;
  upsertPrices: (args: {
    where: PricesWhereUniqueInput;
    create: PricesCreateInput;
    update: PricesUpdateInput;
  }) => PricesPromise;
  deletePrices: (where: PricesWhereUniqueInput) => PricesPromise;
  deleteManyPriceses: (where?: PricesWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  news: (
    where?: NewsSubscriptionWhereInput
  ) => NewsSubscriptionPayloadSubscription;
  prices: (
    where?: PricesSubscriptionWhereInput
  ) => PricesSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Sexe = "MALE" | "FEMALE" | "OTHER";

export type PricesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "price_ASC"
  | "price_DESC";

export type Status = "OJ" | "Actif" | "Moniteur" | "Comite" | "Participant";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "street_ASC"
  | "street_DESC"
  | "city_ASC"
  | "city_DESC"
  | "NPA_ASC"
  | "NPA_DESC"
  | "birthday_ASC"
  | "birthday_DESC"
  | "sexe_ASC"
  | "sexe_DESC"
  | "createDate_ASC"
  | "createDate_DESC"
  | "updateDate_ASC"
  | "updateDate_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "location_ASC"
  | "location_DESC"
  | "transport_ASC"
  | "transport_DESC"
  | "appointment_ASC"
  | "appointment_DESC"
  | "endInscription_ASC"
  | "endInscription_DESC"
  | "startInscription_ASC"
  | "startInscription_DESC"
  | "start_ASC"
  | "start_DESC"
  | "end_ASC"
  | "end_DESC"
  | "picture_ASC"
  | "picture_DESC";

export type Transport = "OWNCAR" | "CAR";

export type NewsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "date_ASC"
  | "date_DESC"
  | "content_ASC"
  | "content_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface PricesUpdateWithWhereUniqueWithoutEventInput {
  where: PricesWhereUniqueInput;
  data: PricesUpdateWithoutEventDataInput;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NewsUpdateInput {
  title?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  event?: Maybe<EventUpdateOneRequiredInput>;
}

export interface EventUpdateManyMutationInput {
  name?: Maybe<String>;
  location?: Maybe<String>;
  transport?: Maybe<Transport>;
  appointment?: Maybe<String>;
  endInscription?: Maybe<DateTimeInput>;
  startInscription?: Maybe<DateTimeInput>;
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  picture?: Maybe<String>;
}

export interface PricesUpdateManyWithWhereNestedInput {
  where: PricesScalarWhereInput;
  data: PricesUpdateManyDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface EventCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  location: String;
  transport?: Maybe<Transport>;
  appointment: String;
  prices?: Maybe<PricesCreateManyWithoutEventInput>;
  endInscription: DateTimeInput;
  startInscription: DateTimeInput;
  start: DateTimeInput;
  end: DateTimeInput;
  organizers?: Maybe<UserCreateManyInput>;
  picture: String;
}

export interface EventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  transport?: Maybe<Transport>;
  transport_not?: Maybe<Transport>;
  transport_in?: Maybe<Transport[] | Transport>;
  transport_not_in?: Maybe<Transport[] | Transport>;
  appointment?: Maybe<String>;
  appointment_not?: Maybe<String>;
  appointment_in?: Maybe<String[] | String>;
  appointment_not_in?: Maybe<String[] | String>;
  appointment_lt?: Maybe<String>;
  appointment_lte?: Maybe<String>;
  appointment_gt?: Maybe<String>;
  appointment_gte?: Maybe<String>;
  appointment_contains?: Maybe<String>;
  appointment_not_contains?: Maybe<String>;
  appointment_starts_with?: Maybe<String>;
  appointment_not_starts_with?: Maybe<String>;
  appointment_ends_with?: Maybe<String>;
  appointment_not_ends_with?: Maybe<String>;
  prices_every?: Maybe<PricesWhereInput>;
  prices_some?: Maybe<PricesWhereInput>;
  prices_none?: Maybe<PricesWhereInput>;
  endInscription?: Maybe<DateTimeInput>;
  endInscription_not?: Maybe<DateTimeInput>;
  endInscription_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endInscription_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endInscription_lt?: Maybe<DateTimeInput>;
  endInscription_lte?: Maybe<DateTimeInput>;
  endInscription_gt?: Maybe<DateTimeInput>;
  endInscription_gte?: Maybe<DateTimeInput>;
  startInscription?: Maybe<DateTimeInput>;
  startInscription_not?: Maybe<DateTimeInput>;
  startInscription_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startInscription_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startInscription_lt?: Maybe<DateTimeInput>;
  startInscription_lte?: Maybe<DateTimeInput>;
  startInscription_gt?: Maybe<DateTimeInput>;
  startInscription_gte?: Maybe<DateTimeInput>;
  start?: Maybe<DateTimeInput>;
  start_not?: Maybe<DateTimeInput>;
  start_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  start_lt?: Maybe<DateTimeInput>;
  start_lte?: Maybe<DateTimeInput>;
  start_gt?: Maybe<DateTimeInput>;
  start_gte?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  end_not?: Maybe<DateTimeInput>;
  end_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  end_lt?: Maybe<DateTimeInput>;
  end_lte?: Maybe<DateTimeInput>;
  end_gt?: Maybe<DateTimeInput>;
  end_gte?: Maybe<DateTimeInput>;
  organizers_every?: Maybe<UserWhereInput>;
  organizers_some?: Maybe<UserWhereInput>;
  organizers_none?: Maybe<UserWhereInput>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  AND?: Maybe<EventWhereInput[] | EventWhereInput>;
  OR?: Maybe<EventWhereInput[] | EventWhereInput>;
  NOT?: Maybe<EventWhereInput[] | EventWhereInput>;
}

export interface PricesCreateManyWithoutEventInput {
  create?: Maybe<
    PricesCreateWithoutEventInput[] | PricesCreateWithoutEventInput
  >;
  connect?: Maybe<PricesWhereUniqueInput[] | PricesWhereUniqueInput>;
}

export interface PricesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  event?: Maybe<EventWhereInput>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  AND?: Maybe<PricesWhereInput[] | PricesWhereInput>;
  OR?: Maybe<PricesWhereInput[] | PricesWhereInput>;
  NOT?: Maybe<PricesWhereInput[] | PricesWhereInput>;
}

export interface PricesCreateWithoutEventInput {
  id?: Maybe<ID_Input>;
  status?: Maybe<PricesCreatestatusInput>;
  price: Float;
}

export interface UserUpdateManyMutationInput {
  lastName?: Maybe<String>;
  firstName?: Maybe<String>;
  email?: Maybe<String>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  NPA?: Maybe<Int>;
  birthday?: Maybe<DateTimeInput>;
  sexe?: Maybe<Sexe>;
  createDate?: Maybe<DateTimeInput>;
  updateDate?: Maybe<DateTimeInput>;
  status?: Maybe<UserUpdatestatusInput>;
}

export interface PricesCreatestatusInput {
  set?: Maybe<Status[] | Status>;
}

export interface PricesUpdateManyMutationInput {
  status?: Maybe<PricesUpdatestatusInput>;
  price?: Maybe<Float>;
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export type NewsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  lastName: String;
  firstName: String;
  email: String;
  street: String;
  city: String;
  NPA: Int;
  birthday: DateTimeInput;
  sexe?: Maybe<Sexe>;
  createDate: DateTimeInput;
  updateDate: DateTimeInput;
  status?: Maybe<UserCreatestatusInput>;
}

export interface NewsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  event?: Maybe<EventWhereInput>;
  AND?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  OR?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  NOT?: Maybe<NewsWhereInput[] | NewsWhereInput>;
}

export interface UserCreatestatusInput {
  set?: Maybe<Status[] | Status>;
}

export interface PricesUpdateInput {
  event?: Maybe<EventUpdateOneRequiredWithoutPricesInput>;
  status?: Maybe<PricesUpdatestatusInput>;
  price?: Maybe<Float>;
}

export interface EventUpdateInput {
  name?: Maybe<String>;
  location?: Maybe<String>;
  transport?: Maybe<Transport>;
  appointment?: Maybe<String>;
  prices?: Maybe<PricesUpdateManyWithoutEventInput>;
  endInscription?: Maybe<DateTimeInput>;
  startInscription?: Maybe<DateTimeInput>;
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  organizers?: Maybe<UserUpdateManyInput>;
  picture?: Maybe<String>;
}

export interface EventCreateOneWithoutPricesInput {
  create?: Maybe<EventCreateWithoutPricesInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface PricesUpdateManyWithoutEventInput {
  create?: Maybe<
    PricesCreateWithoutEventInput[] | PricesCreateWithoutEventInput
  >;
  delete?: Maybe<PricesWhereUniqueInput[] | PricesWhereUniqueInput>;
  connect?: Maybe<PricesWhereUniqueInput[] | PricesWhereUniqueInput>;
  set?: Maybe<PricesWhereUniqueInput[] | PricesWhereUniqueInput>;
  disconnect?: Maybe<PricesWhereUniqueInput[] | PricesWhereUniqueInput>;
  update?: Maybe<
    | PricesUpdateWithWhereUniqueWithoutEventInput[]
    | PricesUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | PricesUpsertWithWhereUniqueWithoutEventInput[]
    | PricesUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<PricesScalarWhereInput[] | PricesScalarWhereInput>;
  updateMany?: Maybe<
    | PricesUpdateManyWithWhereNestedInput[]
    | PricesUpdateManyWithWhereNestedInput
  >;
}

export interface PricesCreateInput {
  id?: Maybe<ID_Input>;
  event: EventCreateOneWithoutPricesInput;
  status?: Maybe<PricesCreatestatusInput>;
  price: Float;
}

export interface EventCreateOneInput {
  create?: Maybe<EventCreateInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpsertNestedInput {
  update: EventUpdateDataInput;
  create: EventCreateInput;
}

export interface PricesUpdateWithoutEventDataInput {
  status?: Maybe<PricesUpdatestatusInput>;
  price?: Maybe<Float>;
}

export interface EventUpdateDataInput {
  name?: Maybe<String>;
  location?: Maybe<String>;
  transport?: Maybe<Transport>;
  appointment?: Maybe<String>;
  prices?: Maybe<PricesUpdateManyWithoutEventInput>;
  endInscription?: Maybe<DateTimeInput>;
  startInscription?: Maybe<DateTimeInput>;
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  organizers?: Maybe<UserUpdateManyInput>;
  picture?: Maybe<String>;
}

export interface PricesUpdatestatusInput {
  set?: Maybe<Status[] | Status>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  NPA?: Maybe<Int>;
  NPA_not?: Maybe<Int>;
  NPA_in?: Maybe<Int[] | Int>;
  NPA_not_in?: Maybe<Int[] | Int>;
  NPA_lt?: Maybe<Int>;
  NPA_lte?: Maybe<Int>;
  NPA_gt?: Maybe<Int>;
  NPA_gte?: Maybe<Int>;
  birthday?: Maybe<DateTimeInput>;
  birthday_not?: Maybe<DateTimeInput>;
  birthday_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_lt?: Maybe<DateTimeInput>;
  birthday_lte?: Maybe<DateTimeInput>;
  birthday_gt?: Maybe<DateTimeInput>;
  birthday_gte?: Maybe<DateTimeInput>;
  sexe?: Maybe<Sexe>;
  sexe_not?: Maybe<Sexe>;
  sexe_in?: Maybe<Sexe[] | Sexe>;
  sexe_not_in?: Maybe<Sexe[] | Sexe>;
  createDate?: Maybe<DateTimeInput>;
  createDate_not?: Maybe<DateTimeInput>;
  createDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createDate_lt?: Maybe<DateTimeInput>;
  createDate_lte?: Maybe<DateTimeInput>;
  createDate_gt?: Maybe<DateTimeInput>;
  createDate_gte?: Maybe<DateTimeInput>;
  updateDate?: Maybe<DateTimeInput>;
  updateDate_not?: Maybe<DateTimeInput>;
  updateDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updateDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updateDate_lt?: Maybe<DateTimeInput>;
  updateDate_lte?: Maybe<DateTimeInput>;
  updateDate_gt?: Maybe<DateTimeInput>;
  updateDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface PricesUpsertWithWhereUniqueWithoutEventInput {
  where: PricesWhereUniqueInput;
  update: PricesUpdateWithoutEventDataInput;
  create: PricesCreateWithoutEventInput;
}

export interface NewsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NewsWhereInput>;
  AND?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  OR?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  NOT?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
}

export interface PricesScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  AND?: Maybe<PricesScalarWhereInput[] | PricesScalarWhereInput>;
  OR?: Maybe<PricesScalarWhereInput[] | PricesScalarWhereInput>;
  NOT?: Maybe<PricesScalarWhereInput[] | PricesScalarWhereInput>;
}

export interface UserUpdateInput {
  lastName?: Maybe<String>;
  firstName?: Maybe<String>;
  email?: Maybe<String>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  NPA?: Maybe<Int>;
  birthday?: Maybe<DateTimeInput>;
  sexe?: Maybe<Sexe>;
  createDate?: Maybe<DateTimeInput>;
  updateDate?: Maybe<DateTimeInput>;
  status?: Maybe<UserUpdatestatusInput>;
}

export interface NewsCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  date: DateTimeInput;
  content: String;
  event: EventCreateOneInput;
}

export interface EventUpdateWithoutPricesDataInput {
  name?: Maybe<String>;
  location?: Maybe<String>;
  transport?: Maybe<Transport>;
  appointment?: Maybe<String>;
  endInscription?: Maybe<DateTimeInput>;
  startInscription?: Maybe<DateTimeInput>;
  start?: Maybe<DateTimeInput>;
  end?: Maybe<DateTimeInput>;
  organizers?: Maybe<UserUpdateManyInput>;
  picture?: Maybe<String>;
}

export interface PricesUpdateManyDataInput {
  status?: Maybe<PricesUpdatestatusInput>;
  price?: Maybe<Float>;
}

export interface EventCreateWithoutPricesInput {
  id?: Maybe<ID_Input>;
  name: String;
  location: String;
  transport?: Maybe<Transport>;
  appointment: String;
  endInscription: DateTimeInput;
  startInscription: DateTimeInput;
  start: DateTimeInput;
  end: DateTimeInput;
  organizers?: Maybe<UserCreateManyInput>;
  picture: String;
}

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface NewsUpdateManyMutationInput {
  title?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface EventUpdateOneRequiredInput {
  create?: Maybe<EventCreateInput>;
  update?: Maybe<EventUpdateDataInput>;
  upsert?: Maybe<EventUpsertNestedInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  lastName?: Maybe<String>;
  firstName?: Maybe<String>;
  email?: Maybe<String>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  NPA?: Maybe<Int>;
  birthday?: Maybe<DateTimeInput>;
  sexe?: Maybe<Sexe>;
  createDate?: Maybe<DateTimeInput>;
  updateDate?: Maybe<DateTimeInput>;
  status?: Maybe<UserUpdatestatusInput>;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventWhereInput>;
  AND?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  OR?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  NOT?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
}

export interface UserUpdatestatusInput {
  set?: Maybe<Status[] | Status>;
}

export interface EventUpdateOneRequiredWithoutPricesInput {
  create?: Maybe<EventCreateWithoutPricesInput>;
  update?: Maybe<EventUpdateWithoutPricesDataInput>;
  upsert?: Maybe<EventUpsertWithoutPricesInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface UserUpdateManyDataInput {
  lastName?: Maybe<String>;
  firstName?: Maybe<String>;
  email?: Maybe<String>;
  street?: Maybe<String>;
  city?: Maybe<String>;
  NPA?: Maybe<Int>;
  birthday?: Maybe<DateTimeInput>;
  sexe?: Maybe<Sexe>;
  createDate?: Maybe<DateTimeInput>;
  updateDate?: Maybe<DateTimeInput>;
  status?: Maybe<UserUpdatestatusInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  street?: Maybe<String>;
  street_not?: Maybe<String>;
  street_in?: Maybe<String[] | String>;
  street_not_in?: Maybe<String[] | String>;
  street_lt?: Maybe<String>;
  street_lte?: Maybe<String>;
  street_gt?: Maybe<String>;
  street_gte?: Maybe<String>;
  street_contains?: Maybe<String>;
  street_not_contains?: Maybe<String>;
  street_starts_with?: Maybe<String>;
  street_not_starts_with?: Maybe<String>;
  street_ends_with?: Maybe<String>;
  street_not_ends_with?: Maybe<String>;
  city?: Maybe<String>;
  city_not?: Maybe<String>;
  city_in?: Maybe<String[] | String>;
  city_not_in?: Maybe<String[] | String>;
  city_lt?: Maybe<String>;
  city_lte?: Maybe<String>;
  city_gt?: Maybe<String>;
  city_gte?: Maybe<String>;
  city_contains?: Maybe<String>;
  city_not_contains?: Maybe<String>;
  city_starts_with?: Maybe<String>;
  city_not_starts_with?: Maybe<String>;
  city_ends_with?: Maybe<String>;
  city_not_ends_with?: Maybe<String>;
  NPA?: Maybe<Int>;
  NPA_not?: Maybe<Int>;
  NPA_in?: Maybe<Int[] | Int>;
  NPA_not_in?: Maybe<Int[] | Int>;
  NPA_lt?: Maybe<Int>;
  NPA_lte?: Maybe<Int>;
  NPA_gt?: Maybe<Int>;
  NPA_gte?: Maybe<Int>;
  birthday?: Maybe<DateTimeInput>;
  birthday_not?: Maybe<DateTimeInput>;
  birthday_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  birthday_lt?: Maybe<DateTimeInput>;
  birthday_lte?: Maybe<DateTimeInput>;
  birthday_gt?: Maybe<DateTimeInput>;
  birthday_gte?: Maybe<DateTimeInput>;
  sexe?: Maybe<Sexe>;
  sexe_not?: Maybe<Sexe>;
  sexe_in?: Maybe<Sexe[] | Sexe>;
  sexe_not_in?: Maybe<Sexe[] | Sexe>;
  createDate?: Maybe<DateTimeInput>;
  createDate_not?: Maybe<DateTimeInput>;
  createDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createDate_lt?: Maybe<DateTimeInput>;
  createDate_lte?: Maybe<DateTimeInput>;
  createDate_gt?: Maybe<DateTimeInput>;
  createDate_gte?: Maybe<DateTimeInput>;
  updateDate?: Maybe<DateTimeInput>;
  updateDate_not?: Maybe<DateTimeInput>;
  updateDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updateDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updateDate_lt?: Maybe<DateTimeInput>;
  updateDate_lte?: Maybe<DateTimeInput>;
  updateDate_gt?: Maybe<DateTimeInput>;
  updateDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export type PricesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface EventUpsertWithoutPricesInput {
  update: EventUpdateWithoutPricesDataInput;
  create: EventCreateWithoutPricesInput;
}

export interface PricesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PricesWhereInput>;
  AND?: Maybe<PricesSubscriptionWhereInput[] | PricesSubscriptionWhereInput>;
  OR?: Maybe<PricesSubscriptionWhereInput[] | PricesSubscriptionWhereInput>;
  NOT?: Maybe<PricesSubscriptionWhereInput[] | PricesSubscriptionWhereInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  lastName: String;
  firstName: String;
  email: String;
  street: String;
  city: String;
  NPA: Int;
  birthday: DateTimeOutput;
  sexe?: Sexe;
  createDate: DateTimeOutput;
  updateDate: DateTimeOutput;
  status: Status[];
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lastName: () => Promise<String>;
  firstName: () => Promise<String>;
  email: () => Promise<String>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  NPA: () => Promise<Int>;
  birthday: () => Promise<DateTimeOutput>;
  sexe: () => Promise<Sexe>;
  createDate: () => Promise<DateTimeOutput>;
  updateDate: () => Promise<DateTimeOutput>;
  status: () => Promise<Status[]>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lastName: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  NPA: () => Promise<AsyncIterator<Int>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  sexe: () => Promise<AsyncIterator<Sexe>>;
  createDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  updateDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<Status[]>>;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PricesSubscriptionPayload {
  mutation: MutationType;
  node: Prices;
  updatedFields: String[];
  previousValues: PricesPreviousValues;
}

export interface PricesSubscriptionPayloadPromise
  extends Promise<PricesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PricesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PricesPreviousValuesPromise>() => T;
}

export interface PricesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PricesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PricesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PricesPreviousValuesSubscription>() => T;
}

export interface Prices {
  id: ID_Output;
  status: Status[];
  price: Float;
}

export interface PricesPromise extends Promise<Prices>, Fragmentable {
  id: () => Promise<ID_Output>;
  event: <T = EventPromise>() => T;
  status: () => Promise<Status[]>;
  price: () => Promise<Float>;
}

export interface PricesSubscription
  extends Promise<AsyncIterator<Prices>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  event: <T = EventSubscription>() => T;
  status: () => Promise<AsyncIterator<Status[]>>;
  price: () => Promise<AsyncIterator<Float>>;
}

export interface PricesNullablePromise
  extends Promise<Prices | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  event: <T = EventPromise>() => T;
  status: () => Promise<Status[]>;
  price: () => Promise<Float>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PricesPreviousValues {
  id: ID_Output;
  status: Status[];
  price: Float;
}

export interface PricesPreviousValuesPromise
  extends Promise<PricesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<Status[]>;
  price: () => Promise<Float>;
}

export interface PricesPreviousValuesSubscription
  extends Promise<AsyncIterator<PricesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<Status[]>>;
  price: () => Promise<AsyncIterator<Float>>;
}

export interface AggregatePrices {
  count: Int;
}

export interface AggregatePricesPromise
  extends Promise<AggregatePrices>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePricesSubscription
  extends Promise<AsyncIterator<AggregatePrices>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface PricesConnection {
  pageInfo: PageInfo;
  edges: PricesEdge[];
}

export interface PricesConnectionPromise
  extends Promise<PricesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PricesEdge>>() => T;
  aggregate: <T = AggregatePricesPromise>() => T;
}

export interface PricesConnectionSubscription
  extends Promise<AsyncIterator<PricesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PricesEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePricesSubscription>() => T;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface NewsEdge {
  node: News;
  cursor: String;
}

export interface NewsEdgePromise extends Promise<NewsEdge>, Fragmentable {
  node: <T = NewsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NewsEdgeSubscription
  extends Promise<AsyncIterator<NewsEdge>>,
    Fragmentable {
  node: <T = NewsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Event {
  id: ID_Output;
  name: String;
  location: String;
  transport?: Transport;
  appointment: String;
  endInscription: DateTimeOutput;
  startInscription: DateTimeOutput;
  start: DateTimeOutput;
  end: DateTimeOutput;
  picture: String;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  location: () => Promise<String>;
  transport: () => Promise<Transport>;
  appointment: () => Promise<String>;
  prices: <T = FragmentableArray<Prices>>(args?: {
    where?: PricesWhereInput;
    orderBy?: PricesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  endInscription: () => Promise<DateTimeOutput>;
  startInscription: () => Promise<DateTimeOutput>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  organizers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  picture: () => Promise<String>;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  transport: () => Promise<AsyncIterator<Transport>>;
  appointment: () => Promise<AsyncIterator<String>>;
  prices: <T = Promise<AsyncIterator<PricesSubscription>>>(args?: {
    where?: PricesWhereInput;
    orderBy?: PricesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  endInscription: () => Promise<AsyncIterator<DateTimeOutput>>;
  startInscription: () => Promise<AsyncIterator<DateTimeOutput>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
  organizers: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  picture: () => Promise<AsyncIterator<String>>;
}

export interface EventNullablePromise
  extends Promise<Event | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  location: () => Promise<String>;
  transport: () => Promise<Transport>;
  appointment: () => Promise<String>;
  prices: <T = FragmentableArray<Prices>>(args?: {
    where?: PricesWhereInput;
    orderBy?: PricesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  endInscription: () => Promise<DateTimeOutput>;
  startInscription: () => Promise<DateTimeOutput>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  organizers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  picture: () => Promise<String>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NewsPreviousValues {
  id: ID_Output;
  title: String;
  date: DateTimeOutput;
  content: String;
}

export interface NewsPreviousValuesPromise
  extends Promise<NewsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface NewsPreviousValuesSubscription
  extends Promise<AsyncIterator<NewsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface NewsSubscriptionPayload {
  mutation: MutationType;
  node: News;
  updatedFields: String[];
  previousValues: NewsPreviousValues;
}

export interface NewsSubscriptionPayloadPromise
  extends Promise<NewsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NewsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NewsPreviousValuesPromise>() => T;
}

export interface NewsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NewsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NewsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NewsPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  lastName: String;
  firstName: String;
  email: String;
  street: String;
  city: String;
  NPA: Int;
  birthday: DateTimeOutput;
  sexe?: Sexe;
  createDate: DateTimeOutput;
  updateDate: DateTimeOutput;
  status: Status[];
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  lastName: () => Promise<String>;
  firstName: () => Promise<String>;
  email: () => Promise<String>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  NPA: () => Promise<Int>;
  birthday: () => Promise<DateTimeOutput>;
  sexe: () => Promise<Sexe>;
  createDate: () => Promise<DateTimeOutput>;
  updateDate: () => Promise<DateTimeOutput>;
  status: () => Promise<Status[]>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  lastName: () => Promise<AsyncIterator<String>>;
  firstName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  street: () => Promise<AsyncIterator<String>>;
  city: () => Promise<AsyncIterator<String>>;
  NPA: () => Promise<AsyncIterator<Int>>;
  birthday: () => Promise<AsyncIterator<DateTimeOutput>>;
  sexe: () => Promise<AsyncIterator<Sexe>>;
  createDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  updateDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<Status[]>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  lastName: () => Promise<String>;
  firstName: () => Promise<String>;
  email: () => Promise<String>;
  street: () => Promise<String>;
  city: () => Promise<String>;
  NPA: () => Promise<Int>;
  birthday: () => Promise<DateTimeOutput>;
  sexe: () => Promise<Sexe>;
  createDate: () => Promise<DateTimeOutput>;
  updateDate: () => Promise<DateTimeOutput>;
  status: () => Promise<Status[]>;
}

export interface EventPreviousValues {
  id: ID_Output;
  name: String;
  location: String;
  transport?: Transport;
  appointment: String;
  endInscription: DateTimeOutput;
  startInscription: DateTimeOutput;
  start: DateTimeOutput;
  end: DateTimeOutput;
  picture: String;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  location: () => Promise<String>;
  transport: () => Promise<Transport>;
  appointment: () => Promise<String>;
  endInscription: () => Promise<DateTimeOutput>;
  startInscription: () => Promise<DateTimeOutput>;
  start: () => Promise<DateTimeOutput>;
  end: () => Promise<DateTimeOutput>;
  picture: () => Promise<String>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  transport: () => Promise<AsyncIterator<Transport>>;
  appointment: () => Promise<AsyncIterator<String>>;
  endInscription: () => Promise<AsyncIterator<DateTimeOutput>>;
  startInscription: () => Promise<AsyncIterator<DateTimeOutput>>;
  start: () => Promise<AsyncIterator<DateTimeOutput>>;
  end: () => Promise<AsyncIterator<DateTimeOutput>>;
  picture: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface News {
  id: ID_Output;
  title: String;
  date: DateTimeOutput;
  content: String;
}

export interface NewsPromise extends Promise<News>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  event: <T = EventPromise>() => T;
}

export interface NewsSubscription
  extends Promise<AsyncIterator<News>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  event: <T = EventSubscription>() => T;
}

export interface NewsNullablePromise
  extends Promise<News | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  event: <T = EventPromise>() => T;
}

export interface NewsConnection {
  pageInfo: PageInfo;
  edges: NewsEdge[];
}

export interface NewsConnectionPromise
  extends Promise<NewsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NewsEdge>>() => T;
  aggregate: <T = AggregateNewsPromise>() => T;
}

export interface NewsConnectionSubscription
  extends Promise<AsyncIterator<NewsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NewsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNewsSubscription>() => T;
}

export interface AggregateNews {
  count: Int;
}

export interface AggregateNewsPromise
  extends Promise<AggregateNews>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNewsSubscription
  extends Promise<AsyncIterator<AggregateNews>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PricesEdge {
  node: Prices;
  cursor: String;
}

export interface PricesEdgePromise extends Promise<PricesEdge>, Fragmentable {
  node: <T = PricesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PricesEdgeSubscription
  extends Promise<AsyncIterator<PricesEdge>>,
    Fragmentable {
  node: <T = PricesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Sexe",
    embedded: false
  },
  {
    name: "Status",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Prices",
    embedded: false
  },
  {
    name: "Transport",
    embedded: false
  },
  {
    name: "News",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
